# CURSOR AI REGELN - NIEMALS IGNORIEREN
# Diese Regeln gelten f√ºr JEDEN Prompt und JEDE Interaktion

## üö® KRITISCHE SICHERHEITSREGELN

### Datei-Operationen
- NIEMALS Dateien l√∂schen, verschieben oder umbenennen ohne explizite Best√§tigung
- IMMER fragen: "Soll ich diese √Ñnderungen durchf√ºhren?" vor strukturellen √Ñnderungen
- Vor dem Markieren von Dateien als "deprecated": Vollst√§ndige Dependency-Analyse durchf√ºhren
- Rechtlich erforderliche Dateien (Impressum, Datenschutz, etc.) sind NIEMALS veraltet oder l√∂schbar

### Code-Analyse vor Aktion
- ERST analysieren, DANN vorschlagen, DANN handeln
- Verwende grep/search um Abh√§ngigkeiten zu finden bevor du Komponenten als ungenutzt einstufst
- Pr√ºfe alle Import-Statements, Routing-Konfigurationen und dynamische Imports

## üìã ARBEITSWEISE

### Mehrstufiger Ansatz bei komplexen Aufgaben
1. **Analyse-Phase**: Vollst√§ndige Bestandsaufnahme ohne √Ñnderungen
2. **Planungs-Phase**: Detaillierte Vorschl√§ge mit Begr√ºndung
3. **Validierungs-Phase**: Warten auf User-Freigabe
4. **Umsetzungs-Phase**: Schrittweise Implementierung
5. Nicht einfach automatisch einen Commit machen, sondern vorher Fragen

### Bei Refactoring IMMER:
- Dependency-Map erstellen
- Alle Verwendungen einer Komponente auflisten
- Potential breaking changes identifizieren
- Alternative L√∂sungswege aufzeigen
- Vorher einen Commit in einem GitHub Branch machen. 
- Fragen, ob du daf√ºr einen neuen Branch erstellen sollst.

## üéØ PROJEKTSPEZIFISCHE REGELN

### React/TypeScript Projekt
- Komponenten in `src/components/` sind aktiv bis Gegenteil bewiesen
- UI-Komponenten k√∂nnen in mehreren Bereichen verwendet werden
- Timeline, Cookie-Einstellungen und rechtliche Komponenten NIEMALS als deprecated markieren

### Code-Qualit√§t
- TypeScript-Typen immer korrekt definieren
- Komponenten-Props vollst√§ndig typisieren
- Performance-Optimierungen nur nach Best√§tigung

## üí¨ KOMMUNIKATIONSREGELN

### Antwort-Format
- Beginne komplexe Antworten mit: "Ich analysiere zuerst..."
- Strukturiere Antworten mit klaren √úberschriften
- Verwende ‚úÖ f√ºr sichere Aktionen, ‚ö†Ô∏è f√ºr potentielle Probleme
- Erkl√§re WARUM du etwas vorschl√§gst

### Bei Unsicherheit
- "Ich bin nicht sicher, ob..." statt falscher Annahmen
- Biete Validierungsschritte an
- Frage nach spezifischen Details wenn unklar

## üîç ANALYSE-CHECKLISTE

Vor jeder gr√∂√üeren √Ñnderung pr√ºfe:
- [ ] Wird die Datei irgendwo importiert?
- [ ] Steht sie in Routing-Konfigurationen?
- [ ] Gibt es dynamische Imports oder lazy loading?
- [ ] Ist sie in package.json oder Config-Dateien referenziert?
- [ ] Handelt es sich um rechtlich erforderliche Inhalte?
- [ ] Wird sie in Tests verwendet?

## ‚ö° PROMPTS RICHTIG INTERPRETIEREN

### Wenn User sagt "l√∂sche veraltete Dateien":
1. Erst analysieren welche Dateien wirklich ungenutzt sind
2. Liste mit Begr√ºndung erstellen
3. User-Best√§tigung einholen
4. Nie rechtliche/kritische Dateien einbeziehen

### Wenn User sagt "strukturiere um":
1. Aktuellen Zustand dokumentieren
2. Verbesserungsvorschl√§ge mit Vor/Nachteilen
3. Migrations-Plan erstellen
4. Schrittweise Umsetzung vorschlagen

### Wenn User sagt "optimiere":
1. Performance-Analyse durchf√ºhren
2. Konkrete Bottlenecks identifizieren
3. Messbare Verbesserungen vorschlagen
4. Risiken und Aufwand bewerten

## üõ°Ô∏è FEHLER-VERMEIDUNG

### H√§ufige Fallen:
- Annahme dass √§hnlich aussehende Dateien identisch sind
- Pattern-Matching statt echter Dependency-Analyse
- √úbersehen von dynamischen Imports
- Ignorieren von rechtlichen Anforderungen

### Sicherheits-Fragen die ich mir stellen muss:
- "K√∂nnte diese √Ñnderung die Website kaputt machen?"
- "Habe ich alle Verwendungsorte gefunden?"
- "Ist das eine Annahme oder ein Fakt?"
- "Sollte ich den User nochmal fragen?"

## üîß MODAL & COMPONENT DEBUGGING REGELN

### NIEMALS sofort fixen - IMMER erst vollst√§ndig analysieren:
1. **Vollst√§ndige Analyse ZUERST**: Schaue dir funktionierende Komponenten derselben Art an
2. **Pattern-Vergleich**: Vergleiche kaputte Komponente mit funktionierenden Implementierungen
3. **Root-Cause-Analysis**: Finde die ECHTE Ursache, nicht nur Symptome
4. **Einfache L√∂sung bevorzugen**: Verwende bew√§hrte Patterns aus der Codebase

### Modal-spezifische Regeln:
- **NIEMALS** komplexe Portal-L√∂sungen ohne Grund implementieren
- **IMMER** schauen wie andere Modals in der Codebase funktionieren
- **AnimatePresence** geh√∂rt in die Parent-Komponente, NICHT ins Modal
- **Early Return** mit `if (!isOpen) return null;` VOR AnimatePresence
- **Einfache Struktur**: `fixed inset-0` ‚Üí `motion.div` ‚Üí Content
- **Event Handling**: Backdrop `onClick={onClose}`, Modal `onClick={stopPropagation}`

### Bei UI-Problemen (Modal schlie√üt sich, etc.):
1. **STOPP** - Nicht sofort Code √§ndern
2. **Analysiere** funktionierende Beispiele derselben Art
3. **Identifiziere** den Unterschied zwischen funktionierend und kaputt
4. **Implementiere** die einfachste L√∂sung basierend auf funktionierenden Patterns
5. **Teste** die L√∂sung bevor weitere √Ñnderungen

### Verbotene Aktionen bei Modal-Problemen:
- ‚ùå Sofort z-index √§ndern ohne Analyse
- ‚ùå Komplexe Event-Handling-Logik hinzuf√ºgen
- ‚ùå Portal-Rendering ohne klaren Grund
- ‚ùå State-Preservation-Hacks implementieren
- ‚ùå Multiple L√∂sungsans√§tze gleichzeitig probieren

### Erlaubte Aktionen:
- ‚úÖ Funktionierende Modal-Implementierungen studieren
- ‚úÖ Einfache Struktur nach bew√§hrtem Muster implementieren
- ‚úÖ Syntax-Fehler beheben durch komplettes Neuschreiben
- ‚úÖ Eine L√∂sung nach der anderen testen

## üé® CODE-STIL PR√ÑFERENZEN

### React/TypeScript:
- Funktionale Komponenten bevorzugen
- TypeScript strict mode befolgen
- Konsistente Namenskonventionen
- Sinnvolle Kommentare f√ºr komplexe Logik

### Ordnerstruktur:
- Logische Gruppierung nach Funktionalit√§t
- Klare Trennung von UI, Logic und Data
- Konsistente Namensgebung

## üîÑ FEEDBACK-LOOP

Nach jeder gr√∂√üeren √Ñnderung:
1. "Funktioniert alles wie erwartet?"
2. "Soll ich weitere Optimierungen vornehmen?"
3. "Gibt es andere Bereiche die angepasst werden sollten?"


## Server neu starten
- Nach √Ñnderungen pr√ºfen, ob Frontend und/oder Backend Server neu gestartet
werden m√ºssen.
- Wenn ja, Server neu starten
- Gleiche Portadresse Verwendungen
- Portadresse ausgeben
---

# WICHTIG: Diese Regeln gelten f√ºr JEDEN Prompt
# Bei Konflikten zwischen User-Anfrage und Sicherheitsregeln: 
# IMMER erst nachfragen und Risiken erkl√§ren
NIEMALS EINEN CODESTAND AUS GITHUB WIEDERHERSTELLEN OHNE ZU FRAGEN UND EINE AUSDR√úCKILICH ANWEISUNG DES USERS!!!!